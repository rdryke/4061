CSCI 4061: Introduction to Operating Systems -- Programmign Assignment 3
Authors: Jordan Anderson and Rob Dryke
Machine(s) used: This code was compiled and tested on kh4250-03.cselabs.umn.edu

CODE ORGANIZATION:
This code acts as a library for a memory manager to allocate blocks of memory for use in other programs and free allocated blocks of memory no longer being used. This is done by intiailizing a pool of usable memory that the allocation and freeing methods alter and assign with pointers. It is assumed that any program utilizing this library will make the appropriate calls in the proper order (see below), but common potential errors (i.e. allocating more memory than available in the pool) are checked for and reported in a file "out.log" generated by the library.

The memory management is achieved through a doubly linked list (the double linkage is used to check the allocated/free status of memory blocks on both sides of any given block for coalescing) of structures used to represent memory blocks with fields designating a pointer, the allocated/free status, the size of the block, and its position in the list. The different functions provided by the library are as follows:

int mm_init(unsigned long size):
	This function initializes the pool of memory with "size" bytes and initializes an out.log for reporting common errors. If an error occurs, -1 is returned. On success, 0 is returned 

char *mm_alloc(unsigned long nbytes)
	This function allocates a memory block of size nbytes. On success,a pointer to the allocated block is returned. If more memory is requested than available, a NULL pointer will be returned and an appropriate message will be written to the out.log file.

int mm_free(char *ptr)
	This function frees the allocated memory block pointed to by ptr.This function also handles coalescing adjacent free blocks by checking the status of both blocks adjacent to the one in question in memory (this is where the double linkage of the list is used). On success, 0 is returned. If ptr points to a block that is not allocated or does not exist (if ptr points to something that is not found in allocated memory) -1 is returned and an appropriate error message is written to the out.log file.

void mm_end(unsigned long *free_num)
	This function counts the number of allocated and free blocks, updating the passed pointer to reflect this number of blocks and freeing the memory pool initialized by the library in mm_init. This essentially signals the end of the use of the library until a new init call is made, and it cleans up the used data structures.

int mm_assign(char *ptr, char val)
	This function checks if *ptr points inside of an allocated block. If it does, then val is assigned to *ptr. If ptr is not within allocated memory, this represents a buffer overflow, and the function returns -1 and writes an appropriate error message to the out.log file.

unsigned long mm_check()
	This function checks the number of memory leaks in the program it is called in (provided all memory has been allocated using this memory management library) and returns this number. This is done by iterating through the memory blocks and seeing how many blocks have been allocated but not freed.

POTENTIAL ERRORS:
Most common errors are reported by the library in out.log. See individual function descriptions above for common errors.

USAGE INSTRUCTIONS:
These library functions can be called to allocate memory for programs. It is important to call the init function before attempting to free or allocate any blocks (you must initialize a memory pool before managing it). The alloc and free functions allocate and free memory blocks respectively (see the above function descriptions for a more details) and will most likely be used the most extensively for memory management. The end function should be called once memory management is done, and it should not be attempted to free memory that has not been allocated or to allocate more memory than initialized by the pool (doing so will result in appropriate error messages in the out.log file). For proper functionality, a large enough memory pool should be initialized by init for whatever is needed, one should keep track of what has been allocated, freed, etc.
